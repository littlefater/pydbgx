#!/usr/bin/env python
"""
Convert C/C++ header file to IDL file.

Usage:
    h2idl.py [FileName].h

Note:
Only tested on dbgeng.h, may not compatible for other header files.
"""

import os
import re
import sys


# additional header file contains some missed data structures
# this file is created manually
AdditionalFile = 'miss.h'


class Interface:
    """Used to store the Interface information"""

    def __init__(self, uuid, name):
        self.__uuid = uuid
        self.__name = name
        self.__base = ''
        self.__alias = ''
        self.__functions = list()

    @property
    def uuid(self):
        return self.__uuid

    @uuid.setter
    def uuid(self, uuid):
        self.__uuid = uuid

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name

    @property
    def base(self):
        return self.__base

    @base.setter
    def base(self, base):
        self.__base = base

    @property
    def alias(self, alias):
        return self.__alias

    @alias.setter
    def alias(self, alias):
        self.__alias = alias

    @property
    def functions(self):
        return self.__functions

    @functions.setter
    def functions(self, function):
        self.__functions = function

    def append_function(self, function):
        self.__functions.append(function)


class Function:
    """Used to store the Function information"""

    def __init__(self, name):
        self.__name = name
        self.__parameters = list()

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        self.__name = name

    @property
    def parameters(self):
        return self.__parameters

    @parameters.setter
    def parameters(self, parameter):
        self.__parameters = parameter
    
    def __format_param(self, param):
        parameter = ''
        
        item = param.split(' ')
        if list != type(item) and len(item) < 3:
            raise 'Function parameters can not be formatted: Error number.'
        
        if -1 != item[0].find('_In'):     
            if -1 != item[0].find('opt'):
                parameter += '[in, optional]  '
            else:
                parameter += '[in]  '        
        elif -1 != item[0].find('_Out'):         
            if -1 != item[0].find('opt'):
                parameter += '[out, optional]  '
            else:
                parameter += '[out]  '
        else:
            raise Exception('Function parameters can not be formatted: Error declare.')
    
        if 'PVOID' == item[-2]:
            parameter += 'void*  '
        elif 'ULONG' == item[-2]:
            parameter += 'unsigned long  '
        elif 'PULONG' == item[-2]:
            parameter += 'unsigned long*  '
        elif 'PSTR' == item[-2]:
            parameter += 'char*  '
        elif 'PCSTR' == item[-2]:
            parameter += 'const char*  '
        elif 'PWSTR' == item[-2]:
            parameter += 'wchar_t*  '
        elif 'PCWSTR' == item[-2]:
            parameter += 'const wchar_t*  '
        elif 'ULONG64' == item[-2]:
            parameter += 'unsigned __int64  '
        elif 'PULONG64' == item[-2]:
            parameter += 'unsigned __int64*  '
        elif 'PBOOL' == item[-2]:
            parameter += 'bool*  '
        elif 'va_list' == item[-2]:
            parameter += 'char*  '
        else:
            parameter += item[-2] + '  '
        
        parameter += item[-1]
        return parameter

    def append_parameter(self, param):
        parameter = self.__format_param(param)
        self.__parameters.append(parameter)
    

def get_interface_by_name(interfaces, name):
    """Retrieve interface from interface list by interface name"""

    for interface in interfaces:
        if interface.name == name:
            return interface


def replace_keyword(data):
    """Replace some variable declaration"""

    data = data.replace('IN ', '')
    data = data.replace('OUT ', '')
    data = data.replace('PCWSTR', 'const wchar_t*')
    return data


def add_indent(data, indent):
    """Add an indent to each line"""

    lines = data.split('\r\n')
    out = ''
    for line in lines:
        out += indent + line + '\r\n'
    return out


def generate_idl_file(filename, interfaces):
    """Generate IDL file"""
    global AdditionalFile

    idl_file = os.path.splitext(filename)[0] + '.idl'
    tlb_file = os.path.splitext(filename)[0] + '.tlb'
    header_file = os.path.splitext(filename)[0] + '_clean.h'
    dbgeng_uuid = '14E1F644-F1FF-4527-A8E0-2B9BCF2BFF7F'        # generated by function comtypes.GUID.create_new()
    # IDL template: https://pythonhosted.org/comtypes/server.html#id3
    out = '// IDL file generated by h2idl.py\r\n'
    out += '// Compile: midl.exe ' + idl_file + ' \\tlb ' + tlb_file + ' /appcompat_optional\r\n\r\n'
    out += 'import "oaidl.idl";\r\n'
    out += 'import "ocidl.idl";\r\n'
    out += '\r\n'
    out += '[\r\n'
    out += '    uuid(' + dbgeng_uuid + '),\r\n'
    out += '    helpstring("DbgEng Type Library")\r\n'
    out += ']\r\n\r\n'
    out += 'library DbgEng {\r\n\r\n'
    out += '    importlib("stdole2.tlb");\r\n\r\n'
    if True == os.path.isfile(AdditionalFile):
        # additional header file contains some missed data structures
        content = open(AdditionalFile, 'rb').read()
        out += add_indent(content, '    ')
    out += '\r\n'
    if True == os.path.isfile(header_file):
        # header file generated by this script
        content = open(header_file, 'rb').read()
        out += add_indent(content, '    ')
    out += '\r\n'
    for interface in interfaces:
        out += '    interface ' + interface.name + ';\r\n'
    out += '    \r\n'
    for interface in interfaces:
        out += '    typedef ' + interface.name + '* ' + interface.alias + ';\r\n'
    out += '    \r\n'
    for interface in interfaces:
        out += '    //' + '-'*70 + '\r\n'
        out += '    //\r\n'
        out += '    // ' + interface.name + '\r\n'
        out += '    //\r\n'
        out += '    //' + '-'*70 + '\r\n\r\n'
        out += '    [\r\n'
        out += '        object,\r\n'
        out += '        uuid(' + interface.uuid + '),\r\n'
        out += '        helpstring("' + interface.name + '")\r\n'
        out += '    ]\r\n\r\n'
        out += '    interface ' + interface.name + ' : ' + interface.base + ' {\r\n\r\n'
        for function in interface.functions:
            paramnum = len(function.parameters)
            if paramnum != 0:
                out += '        HRESULT ' + function.name + ' (\r\n'
                for i in range(0, paramnum-1):
                    out += '            ' + function.parameters[i] + ',\r\n'
                out += '            ' + function.parameters[paramnum-1] + '\r\n'
                out += '        );\r\n\r\n'
            else:
                out += '        HRESULT ' + function.name + '();\r\n\r\n'
        out += '    };\r\n\r\n'
    out += '};\r\n'

    open(idl_file, 'wb').write(out)
    print 'IDL saved to file: ' + idl_file


def generate_header_file(filename, enumerates, structures):
    """Generate the header file contains enumerates and structures"""
    
    header_file = os.path.splitext(filename)[0] + '_clean.h'
    out = '// Header file generated by h2idl.py\r\n\r\n'

    for enum in enumerates:
        out += enum
        out += '\r\n'
    out += '\r\n'
    
    for struct in  structures:
        out += struct
        out += '\r\n'

    out += '// End of the header file'

    open(header_file, 'wb').write(out)
    print 'Enumerates and Structures saved to file: ' + header_file


def parse_header_file(filename):
    """Parse the C/C++ header file"""

    lines = open(filename, 'rb').readlines()
    line_count = len(lines)
    interfaces = list()
    structures = list()
    enumerates = list()
    i = 0
    
    while i < line_count:
        if -1 != lines[i].find('typedef interface DECLSPEC_UUID'):
            # parse the uuid and interface name
            
            uuid_def = lines[i]
            while -1 == lines[i].find(';'):
                uuid_def += lines[i+1]
                i += 1
                
            m = re.search('[\da-f]{8,8}(-[\da-f]{4,4}){3,3}-[\da-f]{12,12}', uuid_def)
            if m is None:
                raise Exception('UUID can not be found in uuid definition.')
            uuid = m.group(0)
            
            m = re.search('\s([^\s]+)\*\s([^\s]+);', uuid_def)
            if m is None:
                raise Exception('Interface name can not be found in uuid definition.')
            name = m.group(1)
            alias = m.group(2)

            interface = Interface(uuid, name)
            interface.alias = alias
            interfaces.append(interface)
        
        if -1 != lines[i].find('DECLARE_INTERFACE_'):
            # parse the interface function
            
            inf_def = lines[i]
            while -1 == lines[i].find('};'):
                inf_def += lines[i+1]
                i += 1
                
            m = re.search('DECLARE_INTERFACE_\(([\w]+), ([\w]+)\)', inf_def)
            if m is None:
                raise Exception('Interface name can not be found in interface definition.')
            name = m.group(1)
            base = m.group(2)
            
            interface = get_interface_by_name(interfaces, name)
            if interface == None:
                raise Exception('Unknown interface')
            interface.base = base
            
            methods = re.findall('STDMETHOD\(.*?\) PURE;', inf_def, re.S)
            if len(methods) == 0:
                raise Exception('Function declare can not be found in interface definition.')
            
            for func_def in methods:
                m = re.search('STDMETHOD\((.*)\)', func_def)
                if m is None:
                    raise Exception('Function name can not be found in function declaration.')
                func_name = m.group(1)
                
                if func_name in ['QueryInterface', 'AddRef', 'Release']:
                    continue
                
                function = Function(func_name)
                func_lines = func_def.split('\r\n')
                if list != type(func_lines):
                    raise Exception('Function parameters can not be parsed.')
                
                for func_line in func_lines:
                    if -1 == func_line.find('STDMETHOD') and \
                       -1 == func_line.find('THIS') and \
                       -1 == func_line.find(') PURE;'):
                        func_param = func_line.strip()
                        func_param = func_param.replace(',', '')
                        func_param = re.sub('/\*.*\*/', '', func_param)
                        function.append_parameter(func_param)
                        
                interface.append_function(function)

        if -1 != lines[i].find('typedef struct'):
            # parse the structure

            struc_def = lines[i]
            if -1 == lines[i].find(';'):
                i += 1
                rest = 1
                while rest:
                    struc_def += replace_keyword(lines[i])
                    i += 1
                    if -1 != lines[i].find('}') and -1 == lines[i].find('{'):
                        rest -= 1
                    if -1 != lines[i].find('{') and -1 == lines[i].find('}'):
                        rest += 1
                struc_def += lines[i]
                structures.append(struc_def)

        if -1 != lines[i].find('#define'):
            m = re.match('#define\s+(.*?)\s+((0x)?[\da-fA-F]+?)\s', lines[i])
            if m is not None:
                if -1 != m.group(2).find('0x'):
                    constant = int(m.group(2), 16)
                else:
                    constant = int(m.group(2))
                if constant <= 0xffffffff:
                    enum_def = 'enum { ' + m.group(1) + ' = ' + m.group(2) + ' };'
                    enumerates.append(enum_def)
                 
        i += 1

    if len(enumerates) > 0 or len(structures) > 0:
        generate_header_file(filename, enumerates, structures)
    
    if len(interfaces) > 0:
        generate_idl_file(filename, interfaces)
    else:
        print 'No interface can be parsed.'


if __name__ == '__main__':
    """Main function"""

    if len(sys.argv) == 2:
        filename = sys.argv[1]
        if True == os.path.isfile(filename):
            parse_header_file(filename)
        else:
            print filename + ' is not a valid file.'
    else:
        print 'Usage: ' + sys.argv[0] + ' [FileName].h'    


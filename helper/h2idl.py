#!/usr/bin/env python
"""
Convert C/C++ header file to IDL file.

Usage:
    h2idl.py [FileName].h

Note:
Only tested on dbgeng.h, may not compatible for other header files.
"""

import os
import re
import sys


class Interface:

    def __init__(self, uuid, name):
        self.uuid = uuid
        self.name = name
        self.base = ''
        self.alias = ''
        self.functions = list()

    def set_base(self, base):
        self.base = base

    def set_alias(self, alias):
        self.alias = alias

    def append_function(self, function):
        self.functions.append(function)


class Function:

    def __init__(self, name):
        self.name = name
        self.parameters = list()

    def __format_param(self, param):
        parameter = ''
        
        item = param.split(' ')
        if list != type(item) and len(item) < 3:
            raise 'Function parameters can not be formatted: Error number.'
        
        if -1 != item[0].find('In'):
            '''
            if -1 != item[0].find('opt'):
                parameter += '[in, optional]  '
            else:
                parameter += '[in]  '
            '''
            parameter += '[in]  '
        elif -1 != item[0].find('Out'):
            '''
            if -1 != item[0].find('opt'):
                parameter += '[out, optional]  '
            else:
                parameter += '[out]  '
            '''
            parameter += '[out]  '
        else:
            raise Exception('Function parameters can not be formatted: Error declare.')
    
        if 'PVOID' == item[-2]:
            parameter += 'void*  '
        elif 'ULONG' == item[-2]:
            parameter += 'unsigned long  '
        elif 'PULONG' == item[-2]:
            parameter += 'unsigned long*  '
        elif 'PSTR' == item[-2]:
            parameter += 'char*  '
        elif 'PCSTR' == item[-2]:
            parameter += 'const char*  '
        elif 'PWSTR' == item[-2]:
            parameter += 'wchar_t*  '
        elif 'PCWSTR' == item[-2]:
            parameter += 'const wchar_t*  '
        elif 'ULONG64' == item[-2]:
            parameter += 'unsigned __int64  '
        elif 'PULONG64' == item[-2]:
            parameter += 'unsigned __int64*  '
        elif 'PBOOL' == item[-2]:
            parameter += 'bool*  '
        elif 'va_list' == item[-2]:
            parameter += 'char*  '
        else:
            parameter += item[-2] + '  '
        
        parameter += item[-1]
        return parameter

    def append_param(self, param):
        parameter = self.__format_param(param)
        self.parameters.append(parameter)


def get_interface_by_name(interfaces, name):
    """Retrieve interface from interface list by interface name"""

    for interface in interfaces:
        if interface.name == name:
            return interface


def generate_idl_file(filename, interfaces):
    """Generate IDL file"""

    outfile = os.path.splitext(filename)[0] + '.idl'
    out = '// File generated by h2idl.py\r\n\r\n'
    out += 'import "oaidl.idl";\r\n'
    out += 'import "ocidl.idl";\r\n'
    if True == os.path.isfile('miss.h'):
        # header file contains some missed structures
        out += 'import "' + os.path.join(os.path.dirname(os.path.realpath(__file__)), 'miss.h') + '";\r\n'
    out += '\r\n'
    out += '[\r\n'
    out += '    uuid(95F974F5-B0AE-44A4-8EB9-FEC4E8136416),\r\n'
    out += '    helpstring("DbgEng Type Library")\r\n'
    out += ']\r\n\r\n'
    out += 'library DbgEng {\r\n\r\n'
    out += '    importlib("stdole32.tlb");\r\n'
    out += '    importlib("stdole2.tlb");\r\n\r\n'
    for interface in interfaces:
        out += '    interface ' + interface.name + ';\r\n'
    out += '    \r\n'
    for interface in interfaces:
        out += '    typedef ' + interface.name + '* ' + interface.alias + ';\r\n'
    out += '    \r\n'
    for interface in interfaces:
        out += '    //' + '-'*70 + '\r\n'
        out += '    //\r\n'
        out += '    // ' + interface.name + '\r\n'
        out += '    //\r\n'
        out += '    //' + '-'*70 + '\r\n\r\n'
        out += '    [\r\n'
        out += '        object,\r\n'
        out += '        uuid(' + interface.uuid + '),\r\n'
        out += '        helpstring("' + interface.name + '")\r\n'
        out += '    ]\r\n\r\n'
        out += '    interface ' + interface.name + ' : ' + interface.base + ' {\r\n\r\n'
        for function in interface.functions:
            paramnum = len(function.parameters)
            if paramnum != 0:
                out += '        HRESULT ' + function.name + ' (\r\n'
                for i in range(0, paramnum-1):
                    out += '            ' + function.parameters[i] + ',\r\n'
                out += '            ' + function.parameters[paramnum-1] + '\r\n'
                out += '        );\r\n\r\n'
            else:
                out += '        HRESULT ' + function.name + '();\r\n\r\n'
        out += '    };\r\n\r\n'
    out += '};\r\n'

    open(outfile, 'wb').write(out)
    print 'IDL saved to file: ' + outfile
      

def parse_header_file(filename):
    """Parse the C/C++ header file"""

    lines = open(filename, 'rb').readlines()
    linenum = len(lines)
    interfaces  = list()
    i = 0
    
    while i < linenum:
        if -1 != lines[i].find('typedef interface DECLSPEC_UUID'):
            # parse the uuid and interface name
            
            uuiddef = lines[i]
            while -1 == lines[i].find(';'):
                uuiddef += lines[i+1]
                i += 1
                
            m = re.search('[\da-f]{8,8}(-[\da-f]{4,4}){3,3}-[\da-f]{12,12}', uuiddef)
            if m is None:
                raise Exception('UUID can not be found in uuid definition.')
            uuid = m.group(0)
            
            m = re.search('\s([^\s]+)\*\s([^\s]+);', uuiddef)
            if m is None:
                raise Exception('Interface name can not be found in uuid definition.')
            name = m.group(1)
            alias = m.group(2)

            interface = Interface(uuid, name)
            interface.set_alias(alias)
            interfaces.append(interface)
            
            
        if -1 != lines[i].find('DECLARE_INTERFACE_'):
            # parse the interface function
            
            intdef = lines[i]
            while -1 == lines[i].find('};'):
                intdef += lines[i+1]
                i += 1
                
            m = re.search('DECLARE_INTERFACE_\(([\w]+), ([\w]+)\)', intdef)
            if m is None:
                raise Exception('Interface name can not be found in interface definition.')
            name = m.group(1)
            base = m.group(2)
            interface = get_interface_by_name(interfaces, name)
            if interface == None:
                raise Exception('Unknown interface')

            interface.set_base(base)
            
            methods = re.findall('STDMETHOD\(.*?\) PURE;', intdef, re.S)
            if len(methods) == 0:
                raise Exception('Function declare can not be found in interface definition.')
            
            for funcdef in methods:
                m = re.search('STDMETHOD\((.*)\)', funcdef)
                if m is None:
                    raise Exception('Function name can not be found in function declaration.')
                funcname = m.group(1)
                if funcname in ['QueryInterface', 'AddRef', 'Release']:
                    continue
                
                function = Function(funcname)
                funclines = funcdef.split('\r\n')
                if list != type(funclines):
                    raise Exception('Function parameters can not be parsed.')
                
                for funcline in funclines:
                    if -1 == funcline.find('STDMETHOD') and \
                       -1 == funcline.find('THIS') and \
                       -1 == funcline.find(') PURE;'):
                        funcparam = funcline.strip()
                        funcparam = funcparam.replace(',', '')
                        funcparam = re.sub('/\*.*\*/', '', funcparam)
                        function.append_param(funcparam)
                        
                interface.append_function(function)
                
        i += 1

    if len(interfaces) > 0:
        generate_idl_file(filename, interfaces)
    else:
        print 'No interface can be parsed.'


if __name__ == '__main__':
    """Main function"""

    if len(sys.argv) == 2:
        filename = sys.argv[1]
        if True == os.path.isfile(filename):
            parse_header_file(filename)
        else:
            print filename + ' is not a valid file.'
    else:
        print 'Usage: ' + sys.argv[0] + ' [FileName].h'    

